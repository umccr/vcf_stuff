#!/usr/bin/env python

import sys
from pprint import pprint
import click
from os.path import isfile, join
from cyvcf2 import VCF, Writer
import re
import numpy as np

from ngs_utils.logger import warn, critical
from ngs_utils.vcf_utils import get_sample_ids, add_cyvcf2_hdr, get_sample_names

from ngs_utils.utils import set_locale
set_locale()

@click.command()
@click.argument('input_file', type=click.Path(exists=True))
@click.option('-o', 'output_file', type=click.Path())
@click.option('-tn', 'tumor_vcf_sample', help='Tumor sample name in the VCF')
@click.option('-nn', 'normal_vcf_sample', help='Normal sample name in the VCF')
def main(input_file, output_file=None, tumor_vcf_sample=None, normal_vcf_sample=None):
    """ Prepares a VCF file for exposing in PCGR:
        adds TUMOR_AF, NORMAL_AF, TUMOR_DP, NORMAL_DP fields.
    """

    # will throw a critical error if it can't guess sample names:
    t_name, n_name = get_sample_names(
        input_file,
        provided_tumor_name=tumor_vcf_sample,
        provided_normal_name=normal_vcf_sample
    )
    t_index, n_index = get_sample_ids(
        input_file,
        provided_t_name=tumor_vcf_sample,
        provided_n_name=normal_vcf_sample
    )
    # t_index will be an array if there are multiple tumors (i.e. tumor_vcf_sample is comma-separated)
    t_indices = [t_index] if isinstance(t_index, int) else t_index

    if not tumor_vcf_sample or not normal_vcf_sample:
        warn(f'Assuming tumor name(s): {t_name}' +
             (f', normal name: {n_name}' if n_name else '') +
             '. If it\'s incorrect, please provide sample name(s) explicitly '
             'with -tn (and -nn options).')

    vcf = VCF(input_file, gts012=True)

    tumor_prefix = 'TUMOR_'
    normal_prefix = 'NORMAL_'

    # Add headers
    new_header = []
    for h in vcf.raw_header.split('\n'):
        # Reached the last row of the header, adding new lines right before CHROM:
        if h.startswith('#CHROM'):
            for tag in ['AF', 'DP', 'VD']:
                if tag in ['VD', 'DP']:
                    type = 'Integer'
                else:
                    type = 'Float'
                if tag in ['AD', 'VD']:
                    number = 'A'
                else:
                    number = '1'

                tumor_tag = tumor_prefix + tag
                normal_tag = normal_prefix + tag

                add_cyvcf2_hdr(vcf, new_header=new_header, id=tumor_tag, number=number, type=type,
                               descr=f"{tag} in tumor sample")
                if n_index is not None:
                    add_cyvcf2_hdr(vcf, new_header=new_header, id=normal_tag, number=number, type=type,
                                   descr=f"{tag} in control sample")

            if not any(h2.startswith(f'##FORMAT=<ID=AD,') for h2 in vcf.raw_header.split('\n')):
                # need to add the AD field into FORMAT:
                add_cyvcf2_hdr(vcf, hdr='FORMAT', new_header=new_header, id='AD', number='R', type='Integer',
                               descr=f"Allelic depths for the ref and alt alleles in the order listed")

        if not any(h.startswith(f'##INFO=<ID={p+tag},')
                   for tag in ['AF', 'DP', 'VD']
                   for p in [tumor_prefix, normal_prefix]):
            # to make sure we don't add duplicated TUMOR_AF,... fields
            new_header.append(h)

    if output_file:
        w = Writer(output_file, vcf)
        w.write_header()
    else:
        w = None
        sys.stdout.write('\n'.join(new_header))

    # Go through each record and add new INFO fields
    for rec in vcf:
        res = _collect_vals_per_sample(rec, n_index, t_indices)
        if res is not None:
            af, dp, vd, ad = res

            # when there are multiple samples, using the sample with the max VD, then DP
            sample_with_max_vd_idx = None
            for t, v in zip(['VD', 'DP', 'AF'], [vd, af, dp]):
                if v is not None:
                    if sample_with_max_vd_idx is None:
                        _, sample_with_max_vd_idx = max(
                            (v[ti], ti)
                            for ti in t_indices
                            if _to_string(v[ti]) is not None)
                    rec.INFO[tumor_prefix + t] = _to_string(v[sample_with_max_vd_idx])

                    if n_index is not None:
                        if len(v) <= n_index:
                            sys.stderr.write(f'Warning: for tag {t}, len of v={len(v)} '
                                             f'is less than index {n_index} of control sample. Record {v}\n')
                        elif v[n_index] is not None:
                            rec.INFO[normal_prefix + t] = _to_string(v[n_index])

            # Writing AD into FORMAT for Purple
            if 'AD' not in rec.FORMAT:
                rec.set_format('AD', ad)

        if w:
            w.write_record(rec)
        else:
            sys.stdout.write(str(rec))

    if w:
        w.close()
    # vcf.close()

    sys.stderr.write('Done\n')


def _to_string(v):
    if isinstance(v, float) or isinstance(v, int):
        return str(v)
    elif len(v.shape) == 0:
        return str(v)
    else:
        return ','.join(map(str, list(v)))



''' 
VarDict
FORMAT/DP,       FORMAT/AF,     FORMAT/VD,                     FORMAT/MQ (somatic), INFO/MQ (germline)

Mutect2                     
FORMAT/DP,       FORMAT/AF,     FORMAT/AD[1:]                  FORMAT/MMQ
                                       
Freebayes                                                                          
FORMAT/DP        FORMAT/AD = ref_count,alt_count               INFO/MQM+INFO/MQMR
                                       
GATK-Haplotype                                                                     
FORMAT/DP        FORMAT/AD = ref_count,alt_count               FORMAT/MMQ
                           
Strelka2 - germline                                                 
SNV:                       
sum(alt_counts)  FORMAT/AD = ref_count,alt_counts              INFO/MQ
INDEL:                       
sum(alt_counts)  FORMAT/AD = ref_count,alt_counts              INFO/MQ
                  
Strelka2 - somatic                                   
SNV:                  
FORMAT/DP        FORMAT/{ALT}U[0] = alt_count(tier1,tier2)     INFO/MQ
INDEL:                  
FORMAT/DP        FORMAT/TIR = alt_count(tier1,tier2)           INFO/MQ

### AF:
    If FORMAT/AF exists, report it as af (vardict, mutect).
    Else, calculate from ad (depth per allele):
        - Check FORMAT/AD (freebayes, gatk-haplotype, strelka2 germline)
        - Else, check FORMAT/*U (strelka2 somatic)

### DP
    If FORMAT/DP exists, report it as dp,
    Else, report sum(ad)

### VD
    if FORMAT/VD exists (varidct), report it as `vd`.
    Else, report ad[1:]
'''


warnings = set()


def _collect_vals_per_sample(rec, control_index, tumor_indices):
    # colleting the following values:
    dp = af = vd = ad = mq = None

    if 'AF' in rec.FORMAT:
        af = rec.format('AF')[:,0]
    if 'DP' in rec.FORMAT:
        dp = rec.format('DP')[:,0]
    if 'VD' in rec.FORMAT:
        vd = rec.format('VD')[:,0:]
    if 'AD' in rec.FORMAT:
        ad = rec.format('AD')[:,0:]

    if dp is None:
        # strelka2 germline?
        if ad is not None:
            dp = np.sum(ad, axis=1)

    if vd is None:
        if ad is not None:
            vd = ad[:,1:2]  # AD=REF,ALT so 1: is the position of ALTs
        elif 'TIR' in rec.FORMAT:  # strelka2 somatic indel?
            vd = np.array([rec.format('TIR')[:,0]]).transpose()
        elif rec.REF + 'U' in rec.FORMAT:  # strelka2 somatic snp?
            vd = np.array([rec.format(alt + 'U')[:,0] for alt in rec.ALT]).transpose()
        else:
            wrn = f'Cannot read variant depth. Unknown caller?'
            if wrn not in warnings:
                warn(f'{wrn} at record: {rec}\n' 
                     'This warning may appear multiple times. Showing once.')
            warnings.add(wrn)
            return None

    if af is None:  # strelka2 before bcbio populated AFs? or SAGE?
        if vd is not None and dp is not None:
            vdt = vd.transpose()
            af = np.true_divide(vdt, dp, where=dp!=0, out=np.zeros(vdt.shape)).transpose()

    if ad is None:
        if rec.REF + 'U' in rec.FORMAT:
            ref_depth = rec.format(rec.REF + 'U')[:,0]
        else:
            ref_depth = dp - np.sum(vd, axis=1)
        ad = np.zeros((vd.shape[0], vd.shape[1] + 1), dtype=vd.dtype)
        ad[:,0] = ref_depth
        ad[:,1:] = vd

    # if 'MQ' in rec.FORMAT:
    #     mq = rec.format('MQ', float)[:,0]
    #     # VarDict has an incorrect MQ header (with Integer type instead of Float),
    #     # so need to specify "float" type here explicitly otherwise MQ won't be parsed
    # elif 'MMQ' in rec.FORMAT:
    #     mq = rec.format('MMQ')[:,0]
    # else:
    #     mq = [None for _ in [control_index] + tumor_indices]
    #     mq[tumor_indices[0]] = rec.INFO.get('MQ')

    return af, dp, vd, ad


def _parse_tag(rec, header_by_tag, tag, d, tumor_index, control_index):
    header = header_by_tag[tag]
    if header:
        if header['HeaderType'] == 'FORMAT':
            data = rec.format(header['ID'], header['python_type'])
            d[tag]['tumor'] = str(data[tumor_index][0])

            sample_dim = data.shape[0]
            if sample_dim >= 2:
                d[tag]['normal'] = str(data[control_index][0])

            if d[tag]['tumor']  == '-2147483648': d[tag]['tumor']  = -1
            if d[tag]['normal'] == '-2147483648': d[tag]['normal'] = -1
        else:
            d[tag]['tumor'] = str(rec.INFO[header['ID']])


if __name__ == '__main__':
    main()

#!/usr/bin/env python
import math
import re
from collections import defaultdict
from os.path import join

import click

from ngs_utils import logger
from ngs_utils.file_utils import verify_file, verify_dir, adjust_path
from ngs_utils.utils import set_locale
set_locale()
from ngs_utils.vcf_utils import get_sample_ids
from ngs_utils.utils import OrderedDefaultDict, flatten
from vcf_stuff import iter_vcf
from vcf_stuff.filtering import add_cyvcf2_filter


PON_HITS = 2


@click.command()
@click.argument('input_file', type=click.Path(exists=True))
@click.option('-o', 'output_file', type=click.Path())
@click.option('-g', 'genome', default='GRCh37')
@click.option('--sb/--no-sb', '--strand-bias', 'strand_bias', is_flag=True, default=True)
@click.option('--hp', 'hp_coef', type=click.INT, help="Set to -1 to disable filtering")
@click.option('--vardict2mut', 'vardict2mut', is_flag=True, default=False)
def main(input_file, output_file, genome=None, strand_bias=None, hp_coef=None, vardict2mut=False):
    tumor_index, control_index = get_sample_ids(input_file)

    if vardict2mut:
        from vcf_stuff.filtering.ngs_reporting.vardict2mut import VarDict2Mut
        from vcf_stuff.filtering.ngs_reporting.config import get_filt_cfg, load_filt_cfg
        filt_cnf = load_filt_cfg(None, target_type='wgs')
        vardict2mut = VarDict2Mut(genome, filt_cnf, None, None)

    iter_vcf(input_file, output_file,
             proc_rec=_somatic_vcf_filter_rec,
             proc_hdr=_somatic_vcf_filter_hdr,
             tumor_index=tumor_index,
             control_index=control_index,
             strand_bias=strand_bias,
             hp_coef=hp_coef,
             vardict2mut=vardict2mut,
             )


def analyse_sage(rec):
    # - add all PASS SAGE variants into the resulting VCF
    # - add FILTER=SAGE_lowconf into resulting VCF if a passing variants is not confirmed by SAGE
    # - extend the set of hotspots by adding PCGR sources?
    # - CACAO: compare hotspots and genes with PCGR and HMF hotspots
    sage_filter = rec.INFO.get('SAGE_FILTER')
    if sage_filter is not None:
        # Sage call overrides all other calls
        if sage_filter == 'PASS':
            rec.FILTER = 'PASS'
        else:
            rec.FILTER = 'SAGE_lowconf'
    return rec


def _somatic_vcf_filter_rec(rec, tumor_index=None, strand_bias=True, hp_coef=None, vardict2mut=None, **kwargs):
    t = rec.INFO.get('PCGR_TIER', '')
    int_tier = int(t.split('_')[1]) if 'TIER' in t else 5  # "TIER_2" -> 2

    rec = analyse_sage(rec)

    is_hs = rec.INFO.get('HMF_HOTSPOT', False) or \
            rec.INFO.get('PCGR_INTOGEN_DRIVER_MUT', False) or \
            rec.INFO.get('PCGR_MUTATION_HOTSPOT', False) or \
            any(t in rec.INFO.get('PCGR_CLINVAR_CLNSIG', '') for t in ['pathogenic', 'uncertain']) or \
            rec.INFO.get('COSMIC_CNT', 0) >= 5 or \
            rec.INFO.get('PCGR_TCGA_PANCANCER_COUNT', 0) >= 5 or \
            rec.INFO.get('ICGC_PCAWG_HITS', 0) >= 3 or \
            rec.INFO.get('SAGE_FILTER') == 'PASS'

    # Keeping all PCGR and HMF known hotspots, as well as variants with tier 1, 2:
    # Tier 1 - variants of strong clinical significance
    # Tier 2 - variants of potential clinical significance
    # Tier 3 - variants of unknown clinical significance [UPD: excluded this tier as it often contains unknown variants, but in known onco/ts genes)
    if int_tier in [1, 2] or is_hs:
        return rec

    # Applying LC, PoN, depth and AF filters to tier 4 and non-coding:
    # Tier 4 - other coding variants
    # Noncoding variants
    # Remove gnomad_AF>=0.01
    # Remove PoN_CNT>=2         # {0 if issnp else 1}'
    # Remove indels in "bad_promoter" tricky regions
    # Remove VD<3
    # Remove VD<5 in tricky regions:
    #        gc15, gc70to75, gc75to80, gc80to85, gc85, low_complexity_51to200bp, low_complexity_gt200bp,
    #        non-GIAB confident,
    #        LCR,
    #        ENCODE,
    #        SEGDUP,
    #        mappability<1
    else:
        # if rec.INFO['TUMOR_AF'] < 0.1:
        #     add_cyvcf2_filter(rec, 'AF10')

        if rec.INFO.get('TRICKY') is None:
            tricky_flags = [k.replace('TRICKY_', '') for k, v in rec.INFO if k.startswith('TRICKY_')]
            if tricky_flags:
                rec.INFO['TRICKY'] = '|'.join(tricky_flags)
                for f in tricky_flags:
                    del rec.INFO[f'TRICKY_{f}']
        tricky_flags = rec.INFO.get('TRICKY', '').split('|')

        # common in gnomAD => likely germline
        if rec.INFO.get('gnomAD_AF', 0.) >= 0.01:
            add_cyvcf2_filter(rec, 'gnomAD_common')

        # in panel of normals => likely an artefact
        pon = rec.INFO.get('PoN_CNT')
        if pon is not None and pon >= PON_HITS:
            add_cyvcf2_filter(rec, 'PoN')

        af = rec.INFO.get('TUMOR_AF')
        dp = rec.INFO.get('TUMOR_DP')
        if af is not None and dp is not None:
            vd = round(af * dp)
        else:
            vd = math.inf

        # specieal treatment for indels
        if not rec.is_snp:
            # removing indels in bad promoter regions - all of those are artefacts in MB benchmark
            if 'bad_promoter' in tricky_flags:
                add_cyvcf2_filter(rec, 'bad_promoter')
            # filtering indels in homopolymers
            if hp_coef != -1:
                rec = _check_hp(rec, af, _coef=hp_coef)

        # filter strand biased variants in vardict
        if strand_bias:
            rec = _vardict_strand_bias(rec, tumor_index)

        if vardict2mut:
            vardict2mut.filter(rec, tumor_index)

        # removing low AF and low DP variants in low complexity regions
        lcr = rec.INFO.get('ENCODE') or rec.INFO.get('SEGDUP') or set(tricky_flags) & {
            'gc15', 'gc70to75', 'gc75to80', 'gc80to85', 'gc85', 'heng_um75-hs37d5',
            'low_complexity_51to200bp', 'low_complexity_gt200bp',
            'LCR'}

        if vd < 3:  # fewer than 3 reads supporting the variant
            add_cyvcf2_filter(rec, 'lowVD')

        elif vd < 5:  # fewer than 5 reads supporting an LCR variant
            if lcr:
                add_cyvcf2_filter(rec, 'LowVD_LCR')
            if not rec.INFO.get('HMF_GIAB_CONF'):
                add_cyvcf2_filter(rec, 'LowVD_GIAB_LCR')
            mpbl = max(flatten([rec.INFO.get('HMF_MAPPABILITY', 1.0)]))
            if mpbl < 0.9:
                add_cyvcf2_filter(rec, 'LowVD_LowMappability')

        # if rec.INFO['TUMOR_AF'] < 0.01:
        #     _add_cyvcf2_filter(rec, 'LowAF')

    return rec


def _somatic_vcf_filter_hdr(vcf):
    vcf.add_filter_to_header({'ID': 'gnomAD_common',        'Description': 'Occurs in gnomAD with frequency above 1%'})
    vcf.add_filter_to_header({'ID': 'PoN',                  'Description': 'Panel of normals hits 1 or more'})
    vcf.add_filter_to_header({'ID': 'bad_promoter',         'Description': 'Indel overlapping bad promoter tricky region'})
    vcf.add_filter_to_header({'ID': 'HP',                   'Description': 'Low AF indel in a homopolymer region (AF lt (INFO/MSI - 1)/0.4%'})
    vcf.add_filter_to_header({'ID': 'lowVD',                'Description': 'AF*DP below 3 (i.e. fewer than 3 reads support the variant)'})
    vcf.add_filter_to_header({'ID': 'LowVD_LCR',            'Description': 'AF*DP below 5 (i.e. fewer than 5 reads support the variant), and overlaps GC=0-15% or GC=70-100%, or an LCR longer than 50bp, or ENCODE low mappability'})
    vcf.add_filter_to_header({'ID': 'LowVD_GIAB_LCR',       'Description': 'AF*DP below 5 (i.e. fewer than 5 reads support the variant), and does not overlap GiaB high confidence regions'})
    vcf.add_filter_to_header({'ID': 'LowVD_LowMappability', 'Description': 'AF*DP below 5 (i.e. fewer than 5 reads support the variant), and overlaps a low mappability region'})
    vcf.add_filter_to_header({'ID': 'StrandBias',           'Description': 'Strand bias as reported by VarDict'})
    vcf.add_filter_to_header({'ID': 'StrandBias1:1',        'Description': 'Strand bias as reported by VarDict'})
    vcf.add_filter_to_header({'ID': 'StrandBias2:0',        'Description': 'Strand bias as reported by VarDict'})
    vcf.add_filter_to_header({'ID': 'StrandBias2:1',        'Description': 'Strand bias as reported by VarDict'})
    vcf.add_filter_to_header({'ID': 'ActGermline',          'Description': 'Strand bias as reported by VarDict'})
    vcf.add_filter_to_header({'ID': 'SAGE_lowconf',         'Description': 'SAGE assigned low confidence to this call'})
    # vcf.add_filter_to_header({'ID': 'LowAF', 'Description': 'DP<25 & AF<5%'})
    # vcf.add_filter_to_header({'ID': 'af10', 'Description': 'AF<10%'})
    vcf.add_info_to_header({'ID': 'AZ_hotspot',  'Description': 'Hotspot based on AZ data knowledge',                                                                   'Type': 'String', 'Number': '1'})
    vcf.add_info_to_header({'ID': 'AZ_artefact', 'Description': 'Artefact based on AZ data knowledge',                                                                  'Type': 'String', 'Number': '1'})
    if not '##INFO=<ID=TRICKY,' in vcf.raw_header:  # legacy
        vcf.add_info_to_header({'ID': 'TRICKY',      'Description': 'Tricky regions from bcbio folders at coverage/problem_regions/GA4GH and coverage/problem_regions/LCR', 'Type': 'String', 'Number': '1'})

# def _somatic_vcf_filter_rec__pysam(rec):
#     """ using pysam
#     """
#     t = rec.info['PCGR_TIER']
#     int_tier = int(t.split('_')[1]) if 'TIER' in t else 5  # "TIER_2" -> 2
#     # Keeping all variants with tier 1, 2, 3:
#     # Tier 1 - variants of strong clinical significance
#     # Tier 2 - variants of potential clinical significance
#     # Tier 3 - variants of unknown clinical significance
#     if int_tier in [1, 2, 3] or rec.info.get('HMF_HOTSPOT', False) is True:
#         return rec
#     # Applying LC, PoN, depth and AF filters to tier 4 and non-coding:
#     # Tier 4 - other coding variants
#     # Noncoding variants
#     # Remove gnomad_AF >0.01
#     # Remove PoN_CNT>0         # {0 if issnp else 1}'
#     # Remove indels in "bad_promoter" tricky regions
#     # Remove DP<30 and AF<10% in tricky regions:
#     #        gc15, gc70to75, gc75to80, gc80to85, gc85, low_complexity_51to200bp, low_complexity_gt200bp,
#     #        non-GIAB confident,
#     #    unless coding in cancer genes
#     # Remove DP<25 and AF<5%
#     else:
#         # if rec.info['TUMOR_AF'] < 0.1:
#         #     rec.filter.add('AF10')
#
#         if rec.info.get('gnomAD_AF', 0.) >= 0.01:
#             rec.filter.add('gnomAD_common')
#
#         # second round of panel of normals
#         pon = rec.info.get('PoN_CNT')
#         if pon is not None and pon >= PON_HITS:
#             rec.filter.add('PoN')
#
#         tricky_set = set(rec.info.get('TRICKY', '').split(','))
#
#         # removing indels in bad promoter regions
#         if len(rec.ref) != len(rec.alts[0]) and 'bad_promoter' in tricky_set:
#             rec.filter.add('bad_promoter')
#
#         # removing low AF and low DP variants in low complexity regions
#         if rec.info['TUMOR_DP'] < 30 and rec.info['TUMOR_AF'] < 0.1:
#             if tricky_set & {'gc15', 'gc70to75', 'gc75to80', 'gc80to85', 'gc85',
#                              'low_complexity_51to200bp', 'low_complexity_gt200bp'}:
#                 rec.filter.add('LowAF_TRICKY')
#             if not rec.info.get('HMF_GIAB_CONF'):
#                 rec.filter.add('LowAF_GIAB_LCR')
#
#         if rec.info['TUMOR_DP'] < 25 and rec.info['TUMOR_AF'] < 0.01:
#             rec.filter.add('LowAF')
#
#     return rec
#
#
# def _somatic_vcf_filter_hdr__pysam(vcf):
#     vcf.header.filters.add('gnomAD_common', None, None, 'Occurs in gnomAD with frequency above 1%')
#     vcf.header.filters.add('PoN', None, None, f'Panel of normals: {PON_HITS} or more hits')
#     vcf.header.filters.add('bad_promoter', None, None, 'Indel overlapping bad promoter tricky region')
#     vcf.header.filters.add('LowAF_TRICKY', None, None, 'DP<30 & AF<10%, and: GC<=15% or GC>=70 or low complexity region >51bp long')
#     vcf.header.filters.add('LowAF_GIAB_LCR', None, None, 'DP<30 & AF<10%, and does not overlap GiaB high confidence regions')
#     vcf.header.filters.add('LowAF', None, None, 'DP<25 & AF<5%')
#     # vcf.add_filter_to_header({'ID': 'af10', 'Description': 'AF<10%'})


def _check_hp(rec, af, _coef=None):
    _coef = _coef or 40

    """
    ### VarDict MSI ###
    Dynamic threshold for indels in homopolymers.
    Motivation:
        ICGC MB test set
                                                                                   TP    FP   FN Recall Prec   F1     F2     F3
        no filtering                                                               318 1378   29 91.64% 18.75% 31.13% 51.56% 65.99%
        static cutoff HP len<=5                                                     69   44  278 19.88% 61.06% 30.00% 22.98%
        AF>=10%, no HP filtering                                                   232   93  115 66.86% 71.38% 69.05% 67.72% 67.29%
        dyn AF cutoff by HP len, coef=40                                           226   80  121 65.13% 73.86% 69.22% 66.71% 65.91%
        dyn AF cutoff by HP len, coef=50                                           231   91  116 66.57% 71.74% 69.06% 67.54% 67.05%
        dyn AF cutoff by HP len, coef=60                                           233  100  114 67.15% 69.97% 68.53% 67.69% 67.42%
        dyn AF cutoff by HP len, coef=Inf (no filt)                                233  265  114 67.15% 46.79% 55.15% 61.77% 64.35%
        dyn AF cutoff by HP len, coef=40, min AF 35%                               225   78  122 64.84% 74.26% 69.23% 66.53% 65.67%
        dyn AF cutoff by HP len, coef=40, min AF 35%, filter VarDict only          232   94  115 66.86% 71.17% 68.95% 67.68% 67.27%
        dyn AF cutoff by HP len, coef=40, min AF 35%, min change len =2bp          225   82  122 64.84% 73.29% 68.81% 66.37% 65.60%
        dyn AF cutoff by HP len, coef=40, min AF 35%, min change len =2bp, HPx1    225   85  122 64.84% 72.58% 68.49% 66.25% 65.54%
        dyn AF cutoff by HP len, coef=40, min AF 35%, min change len =2bp, HPx1,3  225   85  122 64.84% 72.58% 68.49% 66.25% 65.54%
        dyn AF cutoff by HP len, coef=40, min AF 35%, HPx1,3                       225   81  122 64.84% 73.53% 68.91% 66.41% 65.62%

    AF>10% for homopolymers looks like a better idea, though we want to keep low frequency variants


    ### JOINX ###
    - Use approach https://github.com/genome/joinx/tree/master/integration-test/data/vcf-annotate-homopolymers
      to filter non-vardict calls (e.g. strelka2-alone)
      Result:
        - Compiles by travis and runs nicely, however that's only for linux.
        - Unfortunately, annotates only _homo_polymers, i.e. element length = 1.
        - Misses to annotate variants at 2 different HP joints.
        - Most of the variants filtered out as HP are truth:
            bcftools filter -i "HP_JOINX>0 & FILTER=='PASS'" batch1-ensemble-TP.FILT_HP40.Joinx.vcf.gz | bcftools query -f "%CHROM \t %POS \t %FILTER \t %HP_JOINX \t %TIERS\n" | grep tier | wc
            178   # Truth
            ... grep -v tier | wc
            67    # False

            # passed by joinx, filtered by us:
            bcftools filter -e "HP_JOINX>0 | FILTER=='PASS'" batch1-ensemble-TP.FILT_HP40.Joinx.vcf.gz |bcftools query -f "%TIERS\n" | grep tier | wc
            67    # Truth
            ... grep -v tier | wc
            468   # False
      TODO: try on a different truth set
    """

    hp_len = rec.INFO.get('MSILEN')
    hp_repeated = rec.INFO.get('MSI')
    if hp_len is None or hp_repeated is None:
        return rec

    # chg_len = abs(len(rec.REF) - len(rec.ALT[0]))
    # if chg_len > 2 * hp_len:  # caucious with long changes cause it might be real
    #     return rec

    if rec.INFO.get('CALLERS') is not None:
        callers = rec.INFO.get('CALLERS').split(',')
        if len(callers) == 3:  # we wanna only filter vardict
            return rec

    af_threshold = (hp_repeated - 1) / _coef
    af_threshold = min(af_threshold, 0.35)
    # HP/_coef  40   50    60
    #  2       2.5    2    1.67
    #  3       5      4    3.33
    #  4       7.5    6    5
    #  5      10      8    6.67
    #  6      12.5   10    8.33
    #  7      15     12   10
    #  8      17.5   14.  11.7
    #  9      20     16   13.3
    # 10      22.5   18   15

    if hp_repeated >= 3 and af < af_threshold:
        add_cyvcf2_filter(rec, 'HP')
    return rec


def _vardict_strand_bias(rec, tumor_index, damage_p_value=0.01, min_vd=5):
    """
    Filter VarDict variants with single strand support for ALT, while REF has
    both; or REF and ALT have opposite supporting strands.

    BIAS is in format X:Y, where X is the number of strands supporting REF,
    and Y is the number of strands supporting ALT. 0 represents a too low
    P value to call support.

    Evaluation:
        MB: HP40                     1136  228  127 89.94%  83.28% 86.49% 88.53% 89.23%   226    80  121 65.13%  73.86% 69.22% 66.71% 65.91%
        MB: HP40 + SB with min_vd=4  1122  182  141 88.84%  86.04% 87.42% 88.26% 88.55%   225    75  122 64.84%  75.00% 69.55% 66.65% 65.73%    #
        MB: HP40 + SB with min_vd=5  1133  186  130 89.71%  85.90% 87.76% 88.92% 89.31%   225    75  122 64.84%  75.00% 69.55% 66.65% 65.73%    # the best
        MB: HP40 + SB with min_vd=6  1135  200  128 89.87%  85.02% 87.37% 88.85% 89.36%   225    77  122 64.84%  74.50% 69.34% 66.57% 65.69%    #
        MB: HP40 + SB with min_vd=0  1136  214  127 89.94%  84.15% 86.95% 88.72% 89.33%   225    78  122 64.84%  74.26% 69.23% 66.53% 65.67%    #
    """

    if rec.INFO.get('CALLERS') is not None:
        callers = rec.INFO.get('CALLERS').split(',')
        if len(callers) == 3:  # we wanna only filter vardict
            return rec

    if 'BIAS' not in rec.FORMAT or 'SBF' not in rec.FORMAT:
        return rec

    bias = rec.format('BIAS')[tumor_index]
    sbf = float(rec.format('SBF')[tumor_index])

    ref, alt = map(int, bias.split(','))

    if ref < 2 or alt < 2 and sbf is not None:
        if ref == 2 and alt == 1 and sbf < damage_p_value * 10:
            # ALT has only single strand support, while REF has both
            add_cyvcf2_filter(rec, 'StrandBias2:1')

        if ref == 2 and alt == 0 and sbf < damage_p_value:
            # ALT has only single strand support and p-value is low, while reference has both
            add_cyvcf2_filter(rec, 'StrandBias2:0')

        if ref == alt == 1 and sbf < damage_p_value / 10:
            # Filter variants with opposite supporting strands for REF and ALT
            add_cyvcf2_filter(rec, 'StrandBias1:1')

        # if 'ALD' in rec.FORMAT:
        #     # Has only single strand support ({frd}, {rrd}) while reference has both
        #     frd, rrd = rec.format('ALD')[tumor_index,:]
        #     if ref == 2 and float(frd) * float(rrd) == 0 and float(frd) + float(rrd) >= min_vd:
        #         _add_cyvcf2_filter(rec, 'StrandBias')

    return rec


# def _filter_vardict(rec, tumor_index):
#     """
#     Filter VarDict based on https://github.com/AstraZeneca-NGS/VarDict/blob/master/vcf2txt.pl
#     """
# No need in doing this because it's already filtered:
    # min_pmean = 5    # same threshold in vardict.pl
    # min_qmean = 25   # 22.5 in vardict.pl
    # min_mq = 10      # variants usually have a much higher MQ
    # min_vd = 10      # the threshold is too high
    # min_sn = 1.5     # same threshold in vardict.pl

    # if 'PMEAN' in rec.FORMAT:
    #     pmean = rec.format('PMEAN')[tumor_index]
    #     if pmean < min_pmean



if __name__ == '__main__':
    main()


































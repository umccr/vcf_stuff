#!/usr/bin/env python
import math
import click
from ngs_utils.utils import set_locale; set_locale()
from ngs_utils.vcf_utils import get_sample_ids
from vcf_stuff import iter_vcf


PON_HITS = 2


@click.command()
@click.argument('input_file', type=click.Path(exists=True))
@click.option('-o', 'output_file', type=click.Path())
@click.option('-g', 'genome', default='GRCh37')
@click.option('-f', '--ref-fasta', 'ref_fasta', type=click.Path(exists=True))
def main(input_file, output_file, genome=None, ref_fasta=None):
    tumor_index, control_index = get_sample_ids(input_file)

    iter_vcf(input_file, output_file,
             proc_rec=_somatic_vcf_filter_rec,
             proc_hdr=_somatic_vcf_filter_hdr,
             tumor_index=tumor_index,
             control_index=control_index)


def _add_cyvcf2_filter(rec, filt):
    filters = rec.FILTER.split(';') if rec.FILTER else []
    filters.append(filt)
    f = ';'.join(filters)
    rec.FILTER = str(f)
    return rec


def _somatic_vcf_filter_rec(rec, tumor_index=None, **kwargs):
    t = rec.INFO.get('PCGR_TIER', '')
    int_tier = int(t.split('_')[1]) if 'TIER' in t else 5  # "TIER_2" -> 2
    # Keeping all variants with tier 1, 2, 3:
    # Tier 1 - variants of strong clinical significance
    # Tier 2 - variants of potential clinical significance
    # Tier 3 - variants of unknown clinical significance [UPD: excluded this tier as it often contains unknown variants, but in known onco/ts genes)

    tricky_flags = [k.replace('TRICKY_', '') for k, v in rec.INFO if k.startswith('TRICKY_')]
    if tricky_flags:
        rec.INFO['TRICKY'] = ','.join(tricky_flags)
    for f in tricky_flags:
        del rec.INFO[f'TRICKY_{f}']

    is_hs = rec.INFO.get('HMF_HOTSPOT', False) or \
            rec.INFO.get('PCGR_INTOGEN_DRIVER_MUT', False) or \
            rec.INFO.get('PCGR_MUTATION_HOTSPOT', False) or \
            any(t in rec.INFO.get('PCGR_CLINVAR_CLNSIG', '') for t in ['pathogenic', 'uncertain']) or \
            rec.INFO.get('COSMIC_CNT', 0) >= 5 or \
            rec.INFO.get('PCGR_TCGA_PANCANCER_COUNT', 0) >= 5 or \
            rec.INFO.get('ICGC_PCAWG_HITS', 0) >= 2

    if int_tier in [1, 2] or is_hs:
        return rec
    # Applying LC, PoN, depth and AF filters to tier 4 and non-coding:
    # Tier 4 - other coding variants
    # Noncoding variants
    # Remove gnomad_AF>0.01
    # Remove PoN_CNT>=2         # {0 if issnp else 1}'
    # Remove indels in "bad_promoter" tricky regions
    # Remove DP*AF<3
    # Remove DP*AF<5 in tricky regions:
    #        gc15, gc70to75, gc75to80, gc80to85, gc85, low_complexity_51to200bp, low_complexity_gt200bp,
    #        non-GIAB confident,
    #        LCR,
    #        ENCODE,
    #        mappability<1
    else:
        # if rec.INFO['TUMOR_AF'] < 0.1:
        #     _add_cyvcf2_filter(rec, 'AF10')

        # common in gnomAD => likely germline
        if rec.INFO.get('gnomAD_AF', 0.) >= 0.01:
            _add_cyvcf2_filter(rec, 'gnomAD_common')

        # in panel of normals => likely an artefact
        pon = rec.INFO.get('PoN_CNT')
        if pon is not None and pon >= PON_HITS:
            _add_cyvcf2_filter(rec, 'PoN')

        af = rec.INFO.get('TUMOR_AF')
        dp = rec.INFO.get('TUMOR_DP')
        if af is not None and dp is not None:
            vd = round(af * dp)
        else:
            vd = math.inf

        # specieal treatment for indels
        if not rec.is_snp:
            # removing indels in bad promoter regions - all of those are artefacts in MB benchmark
            if 'bad_promoter' in tricky_flags:
                _add_cyvcf2_filter(rec, 'bad_promoter')
            # filtering indels in homopolymers
            rec = _check_msi(rec, af)

        # filter strand biased variants in vardict
        rec = vardict_strand_bias(rec, tumor_index)

        # removing low AF and low DP variants in low complexity regions
        lcr = rec.INFO.get('ENCODE') or set(tricky_flags) & {
            'gc15', 'gc70to75', 'gc75to80', 'gc80to85', 'gc85', 'heng_um75-hs37d5',
            'low_complexity_51to200bp', 'low_complexity_gt200bp',
            'LCR'}

        if vd < 3:  # fewer than 3 reads supporting the variant
            _add_cyvcf2_filter(rec, 'lowVD')

        elif vd < 5:  # fewer than 5 reads supporting an LCR variant
            if lcr:
                _add_cyvcf2_filter(rec, 'LowVD_LCR')
            if not rec.INFO.get('HMF_GIAB_CONF'):
                _add_cyvcf2_filter(rec, 'LowVD_GIAB_LCR')
            mpbl = max(map(float, rec.INFO.get('HMF_MAPPABILITY', '1.0').split(',')))
            if mpbl < 1.0:
                _add_cyvcf2_filter(rec, 'LowVD_LowMappability')

        # if rec.INFO['TUMOR_AF'] < 0.01:
        #     _add_cyvcf2_filter(rec, 'LowAF')

    return rec


def _somatic_vcf_filter_hdr(vcf):
    vcf.add_filter_to_header({'ID': 'gnomAD_common',        'Description': 'Occurs in gnomAD with frequency above 1%'})
    vcf.add_filter_to_header({'ID': 'PoN',                  'Description': 'Panel of normals hits 1 or more'})
    vcf.add_filter_to_header({'ID': 'bad_promoter',         'Description': 'Indel overlapping bad promoter tricky region'})
    vcf.add_filter_to_header({'ID': 'HP',                   'Description': 'Low AF indel in a homopolymer region (AF lt (INFO/MSI - 1)/0.4%'})
    vcf.add_filter_to_header({'ID': 'lowVD',                'Description': 'AF*DP below 3 (i.e. fewer than 3 reads support the variant)'})
    vcf.add_filter_to_header({'ID': 'LowVD_LCR',            'Description': 'AF*DP below 5 (i.e. fewer than 5 reads support the variant), and overlaps LCR: GC=0-15% or GC=70-100%, or a low complexity region longer than 50bp long, or ENCODE low mappability'})
    vcf.add_filter_to_header({'ID': 'LowVD_GIAB_LCR',       'Description': 'AF*DP below 5 (i.e. fewer than 5 reads support the variant), and does not overlap GiaB high confidence regions'})
    vcf.add_filter_to_header({'ID': 'LowVD_LowMappability', 'Description': 'AF*DP below 5 (i.e. fewer than 5 reads support the variant), and overlaps a low mappability region'})
    vcf.add_filter_to_header({'ID': 'StrandBias',           'Description': 'Strand bias as reported by VarDict'})
    # vcf.add_filter_to_header({'ID': 'LowAF', 'Description': 'DP<25 & AF<5%'})
    # vcf.add_filter_to_header({'ID': 'af10', 'Description': 'AF<10%'})
    vcf.add_info_to_header({'ID': 'TRICKY','Description': 'Tricky regions from bcbio\'s coverage/problem_regions/GA4GH and coverage/problem_regions/LCR', 'Type': 'String', 'Number': '1'})

# def _somatic_vcf_filter_rec__pysam(rec):
#     """ using pysam
#     """
#     t = rec.info['PCGR_TIER']
#     int_tier = int(t.split('_')[1]) if 'TIER' in t else 5  # "TIER_2" -> 2
#     # Keeping all variants with tier 1, 2, 3:
#     # Tier 1 - variants of strong clinical significance
#     # Tier 2 - variants of potential clinical significance
#     # Tier 3 - variants of unknown clinical significance
#     if int_tier in [1, 2, 3] or rec.info.get('HMF_HOTSPOT', False) is True:
#         return rec
#     # Applying LC, PoN, depth and AF filters to tier 4 and non-coding:
#     # Tier 4 - other coding variants
#     # Noncoding variants
#     # Remove gnomad_AF >0.01
#     # Remove PoN_CNT>0         # {0 if issnp else 1}'
#     # Remove indels in "bad_promoter" tricky regions
#     # Remove DP<30 and AF<10% in tricky regions:
#     #        gc15, gc70to75, gc75to80, gc80to85, gc85, low_complexity_51to200bp, low_complexity_gt200bp,
#     #        non-GIAB confident,
#     #    unless coding in cancer genes
#     # Remove DP<25 and AF<5%
#     else:
#         # if rec.info['TUMOR_AF'] < 0.1:
#         #     rec.filter.add('AF10')
#
#         if rec.info.get('gnomAD_AF', 0.) >= 0.01:
#             rec.filter.add('gnomAD_common')
#
#         # second round of panel of normals
#         pon = rec.info.get('PoN_CNT')
#         if pon is not None and pon >= PON_HITS:
#             rec.filter.add('PoN')
#
#         tricky_set = set(rec.info.get('TRICKY', '').split(','))
#
#         # removing indels in bad promoter regions
#         if len(rec.ref) != len(rec.alts[0]) and 'bad_promoter' in tricky_set:
#             rec.filter.add('bad_promoter')
#
#         # removing low AF and low DP variants in low complexity regions
#         if rec.info['TUMOR_DP'] < 30 and rec.info['TUMOR_AF'] < 0.1:
#             if tricky_set & {'gc15', 'gc70to75', 'gc75to80', 'gc80to85', 'gc85',
#                              'low_complexity_51to200bp', 'low_complexity_gt200bp'}:
#                 rec.filter.add('LowAF_TRICKY')
#             if not rec.info.get('HMF_GIAB_CONF'):
#                 rec.filter.add('LowAF_GIAB_LCR')
#
#         if rec.info['TUMOR_DP'] < 25 and rec.info['TUMOR_AF'] < 0.01:
#             rec.filter.add('LowAF')
#
#     return rec
#
#
# def _somatic_vcf_filter_hdr__pysam(vcf):
#     vcf.header.filters.add('gnomAD_common', None, None, 'Occurs in gnomAD with frequency above 1%')
#     vcf.header.filters.add('PoN', None, None, f'Panel of normals: {PON_HITS} or more hits')
#     vcf.header.filters.add('bad_promoter', None, None, 'Indel overlapping bad promoter tricky region')
#     vcf.header.filters.add('LowAF_TRICKY', None, None, 'DP<30 & AF<10%, and: GC<=15% or GC>=70 or low complexity region >51bp long')
#     vcf.header.filters.add('LowAF_GIAB_LCR', None, None, 'DP<30 & AF<10%, and does not overlap GiaB high confidence regions')
#     vcf.header.filters.add('LowAF', None, None, 'DP<25 & AF<5%')
#     # vcf.add_filter_to_header({'ID': 'af10', 'Description': 'AF<10%'})


def _check_msi(rec, af, _coef=40):
    """
    Dynamic threshold for indels in homopolymers.
    Motivation:

               Sample    SNP                                               INDEL
                                    TP   FP   FN Recall    Prec     F1     F2     F3    TP    FP   FN Recall    Prec     F1     F2     F3
         MB: no filtering         1183  540   80 93.67%  68.66% 79.24% 87.31% 90.37%   318  1378   29 91.64%  18.75% 31.13% 51.56% 65.99%
         MB: static cutoff HP<=5  1136  228  127 89.94%  83.28% 86.49% 88.53% 89.23%    69    44  278 19.88%  61.06% 30.00% 22.98%
         MB: AF>=10%, no HP filt   948   68  315 75.06%  93.31% 83.19% 78.11% 76.56%   232    93  115 66.86%  71.38% 69.05% 67.72% 67.29%
         MB: _coef=40             1136  228  127 89.94%  83.28% 86.49% 88.53% 89.23%   226    80  121 65.13%  73.86% 69.22% 66.71% 65.91%
         MB: _coef=50             1136  228  127 89.94%  83.28% 86.49% 88.53% 89.23%   231    91  116 66.57%  71.74% 69.06% 67.54% 67.05%
         MB: _coef=60             1136  228  127 89.94%  83.28% 86.49% 88.53% 89.23%   233   100  114 67.15%  69.97% 68.53% 67.69% 67.42%
         MB: _coef=Inf (no filt)  1136  228  127 89.94%  83.28% 86.49% 88.53% 89.23%   233   265  114 67.15%  46.79% 55.15% 61.77% 64.35%

    AF>10% for homopolymers looks like a better idea, though
    """

    hp_len = rec.INFO.get('MSILEN')
    if hp_len is None:
        return rec

    hp_repeated = rec.INFO.get('MSI')
    af_threshold = (hp_repeated - 1) / _coef
    # HP  AF
    # 1   0
    # 2   2,5%
    # 3   5%
    # 4   7,5%
    # 5  10%
    # 6  12,5%
    # 7  15%
    # 8  17,5%
    # 9  20%
    if af < af_threshold:
        _add_cyvcf2_filter(rec, 'HP')
    return rec


def vardict_strand_bias(rec, tumor_index, damage_p_value=0.01):
    """
    Filter VarDict variants with single strand support for ALT, while REF has both;
    or REF and ALT have opposite supporting strands.
    """

    if 'BIAS' not in rec.FORMAT or 'SBF' not in rec.FORMAT:
        return rec

    bias = rec.format('BIAS')[tumor_index]
    sbf = float(rec.format('SBF')[tumor_index])

    if bias != '2:2' and sbf is not None:
        if bias == '2:1' and sbf < damage_p_value * 10:
            # Has only single strand support 2:1 while reference has both
            _add_cyvcf2_filter(rec, 'StrandBias')

        if bias == '2:0' and sbf < damage_p_value:
            # Has only single strand support 2:0 and p-value < {self.damage_p_value}' + while reference has both
            _add_cyvcf2_filter(rec, 'StrandBias')

        if bias == '1:1' and sbf < damage_p_value / 10:
            # Filter variants with opposite supporting strands for REF and ALT
            _add_cyvcf2_filter(rec, 'StrandBias')

        if 'ALD' in rec.FORMAT:
            #  Has only single strand support ({frd}, {rrd}) while reference has both
            frd, rrd = rec.format('ALD')[tumor_index,:]
            if bias.startswith('2') and float(frd) * float(rrd) == 0 and float(frd) + float(rrd) >= 4:
                _add_cyvcf2_filter(rec, 'StrandBias')

    return rec

if __name__ == '__main__':
    main()
